<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Golang中的单例模式</title>
      <link href="/2023/10/19/golang-single-instance/"/>
      <url>/2023/10/19/golang-single-instance/</url>
      
        <content type="html"><![CDATA[<p>Go语言中如何实现一个单例？很多Go语言学习者可能觉得这是一个很简单的问题，闭着眼都能写出来。但是其代码实现往往存在不少问题，下面先看一下一些常见的错误。</p><h1 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h1><h2 id="没考虑并发安全"><a href="#没考虑并发安全" class="headerlink" title="没考虑并发安全"></a>没考虑并发安全</h2><p>示例代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">type User struct &#123;</span><br><span class="line">    Name string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var instance *User</span><br><span class="line"></span><br><span class="line">func GetInstance() *User &#123;</span><br><span class="line">    if instance == nil &#123;</span><br><span class="line">        instance = &amp;User&#123;</span><br><span class="line">            Name: &quot;xiaoming&quot;,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return instance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面示例中，多个goroutine有可能同时执行第一个检查，然后instance就会被执行多次赋值操作，在某些instance只能被赋值一次的业务场景，该操作就可能导致与期望不一致。</p><h2 id="忽略代码非原子操作问题"><a href="#忽略代码非原子操作问题" class="headerlink" title="忽略代码非原子操作问题"></a>忽略代码非原子操作问题</h2><p>针对上面示例存在的并发问题，部分开发人员想我加个锁，问题不就解决了吗，于是将上面示例代码修改成如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">type User struct &#123;</span><br><span class="line">    Name string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var (</span><br><span class="line">    lock     sync.Mutex</span><br><span class="line">    instance *User</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func GetInstance() *User &#123;</span><br><span class="line">    if instance == nil &#123;</span><br><span class="line">        lock.Lock()</span><br><span class="line">        defer lock.Unlock()</span><br><span class="line">        if instance == nil &#123;</span><br><span class="line">            instance = &amp;User&#123;</span><br><span class="line">                Name: &quot;xiaoming&quot;,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return instance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上示例代码看似已经很完美了，但是当我们用go run -race检查时，会提示这段代码有DATA RACE的警告：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">==================</span><br><span class="line">WARNING: DATA RACE</span><br><span class="line">Write at 0x00010507e6a0 by goroutine 6:</span><br><span class="line">  main.GetInstance()</span><br><span class="line">      /Users/chenzeping/go/src/gostudy/race/go_race_demo.go:22 +0xf4</span><br><span class="line">  main.main.func1()</span><br><span class="line">      /Users/chenzeping/go/src/gostudy/race/go_race_demo.go:32 +0x20</span><br><span class="line"></span><br><span class="line">Previous read at 0x00010507e6a0 by goroutine 8:</span><br><span class="line">  main.GetInstance()</span><br><span class="line">      /Users/chenzeping/go/src/gostudy/race/go_race_demo.go:18 +0x30</span><br><span class="line">  main.main.func3()</span><br><span class="line">      /Users/chenzeping/go/src/gostudy/race/go_race_demo.go:38 +0x20</span><br><span class="line"></span><br><span class="line">Goroutine 6 (running) created at:</span><br><span class="line">  main.main()</span><br><span class="line">      /Users/chenzeping/go/src/gostudy/race/go_race_demo.go:31 +0x28</span><br><span class="line"></span><br><span class="line">Goroutine 8 (running) created at:</span><br><span class="line">  main.main()</span><br><span class="line">      /Users/chenzeping/go/src/gostudy/race/go_race_demo.go:37 +0x40</span><br><span class="line">==================</span><br></pre></td></tr></table></figure><p>大家可以亲自试一下，go_race_demo.go完整代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;sync&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type User struct &#123;</span><br><span class="line">    Name string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var (</span><br><span class="line">    lock     sync.Mutex</span><br><span class="line">    instance *User</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func GetInstance() *User &#123;</span><br><span class="line">    if instance == nil &#123;</span><br><span class="line">        lock.Lock()</span><br><span class="line">        defer lock.Unlock()</span><br><span class="line">        if instance == nil &#123;</span><br><span class="line">            instance = &amp;User&#123;</span><br><span class="line">                Name: &quot;xiaoming&quot;,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return instance</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    go func() &#123;</span><br><span class="line">        fmt.Println(&quot;goroutine A&quot;, GetInstance())</span><br><span class="line">    &#125;()</span><br><span class="line">    go func() &#123;</span><br><span class="line">        fmt.Println(&quot;goroutine B&quot;, GetInstance())</span><br><span class="line">    &#125;()</span><br><span class="line">    go func() &#123;</span><br><span class="line">        fmt.Println(&quot;goroutine C&quot;, GetInstance())</span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之所以会出现DATA RACE警告，是因为CPU在执行instance&#x3D;&amp;User{Name:”xiaoming”}这行代码时，并不是原子操作，这个赋值可能是会有几步指令，比如</p><ol><li>先new一个User</li><li>然后设置Name&#x3D;xiaoming</li><li>最后把了new的对象赋值给instance</li></ol><p>而且多个指令执行时，有可能会是乱序的，如果发生了乱序，可能会变成</p><ol><li>先了new一个User</li><li>然后再赋值给instance</li><li>最后再设置Name&#x3D;xiaoming</li></ol><p>goroutine A进来时拿到锁，然后执行instance&#x3D;&amp;User{Name:”xiaoming”}这句代码，这个时候有可能刚执行完指令2，还未执行指令3时，goroutine B对instance是否为nil进行了判断，发现非nil，就直接将instance的数据返回了，而此时的instance是个半初始化状态，这时就会有问题。</p><h1 id="正确姿势"><a href="#正确姿势" class="headerlink" title="正确姿势"></a>正确姿势</h1><p>解决上面的问题，我们可以通过原子化加载并设置一个标志flag，该标志表明我们是否已初始化instance，改造后代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">type User struct &#123;</span><br><span class="line">    Name string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var (</span><br><span class="line">    lock     sync.Mutex</span><br><span class="line">    instance *User</span><br><span class="line">    flag     uint32</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func GetInstance() *User &#123;</span><br><span class="line">    if atomic.LoadUint32(&amp;flag) != 1 &#123;</span><br><span class="line">        lock.Lock()</span><br><span class="line">        defer lock.Unlock()</span><br><span class="line">        if instance == nil &#123;</span><br><span class="line">            instance = &amp;User&#123;</span><br><span class="line">                Name: &quot;xiaoming&quot;,</span><br><span class="line">            &#125;</span><br><span class="line">            atomic.StoreUint32(&amp;flag, 1)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return instance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，我们主要是通过atomic.store和lock来保证flag和instance的修改对其他的goroutine可见，通过atomic.LoadUint32(&amp;flag)和double check来保证instance只会被初始化一次。<br>但是，这看起来有点繁琐，其实Go语言标准库sync已经为我们提供了实现goroutine同步比较好的方式，通过<code>sync.Once</code>来实现，示例代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">type User struct &#123;</span><br><span class="line">    Name string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var (</span><br><span class="line">    once sync.Once</span><br><span class="line">    instance *User</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func GetInstance() *User &#123;</span><br><span class="line">    once.Do(func() &#123;</span><br><span class="line">        instance = &amp;User&#123;</span><br><span class="line">            Name: &quot;xiaoming&quot;,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    return instance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，我们可以首选<code>sync.Once</code>来实现单例模式。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 编程语言 </category>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
            <tag> 单例 </tag>
            
            <tag> 并发 </tag>
            
            <tag> Go内存模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Apple arm架构下gomonkey报错问题解决</title>
      <link href="/2023/10/11/apple-arm-gomonkey-error/"/>
      <url>/2023/10/11/apple-arm-gomonkey-error/</url>
      
        <content type="html"><![CDATA[<h1 id="问题一：-undefined-buildJmpDirective"><a href="#问题一：-undefined-buildJmpDirective" class="headerlink" title="问题一： undefined: buildJmpDirective"></a>问题一： undefined: buildJmpDirective</h1><p>需要将gomonkey升级到github.com&#x2F;agiledragon&#x2F;gomonkey&#x2F;v2</p><h1 id="问题二：permission-denied"><a href="#问题二：permission-denied" class="headerlink" title="问题二：permission denied"></a>问题二：permission denied</h1><p>修改modify_binary_darwin.go文件，去掉syscall.PROT_EXEC<br><img src="/2023/10/11/apple-arm-gomonkey-error/1280X1280.png"></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 编程语言 </category>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> arm </tag>
            
            <tag> gomonkey </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL中varchar类型长度设置为多少合适</title>
      <link href="/2023/10/11/mysql-varchar-length/"/>
      <url>/2023/10/11/mysql-varchar-length/</url>
      
        <content type="html"><![CDATA[<h1 id="varchar类型长度常见设置"><a href="#varchar类型长度常见设置" class="headerlink" title="varchar类型长度常见设置"></a>varchar类型长度常见设置</h1><p>经常会看到大家设置varchar类型长度，一般都设置为255，那为什么不是其他数字呢？<br><br>以下针对我们常用的<em>innodb</em>存储引擎。</p><h1 id="varchar-255-和varchar-256-区别"><a href="#varchar-255-和varchar-256-区别" class="headerlink" title="varchar(255)和varchar(256)区别"></a>varchar(255)和varchar(256)区别</h1><p>varchar(255)需要1个字节记录字符串长度，而varchar(256)则需要2个字节记录字符串长度。<br>因此varchar(255)和varchar(256)，优先选择varchar(255)。</p><h1 id="varchar-64-和varchar-255-区别"><a href="#varchar-64-和varchar-255-区别" class="headerlink" title="varchar(64)和varchar(255)区别"></a>varchar(64)和varchar(255)区别</h1><ol><li>对于字符串长度超过64的，varchar(64)的sql会报错  </li><li>对于字符串长度不超过64的，两者在磁盘存储上没有区别<ol><li>都是1个字节记录字符串长度</li><li>由于innodb将varchar类型数据独立于聚簇索引单独存储，占用空间取决于实际字符串长度</li></ol></li></ol><p>所以如果字段长度不超过64，那么使用varchar(255)也没问题，但是如果该字段建<strong>索引</strong>了，那就不一样了：<br>建立索引时如果没有限制索引的大小，索引长度会默认采用的该字段类型的长度，因此用varchar(255)类型会占用更多的空间，加载索引信息时也会占用更多的内存，索引性能相对来说会较差。</p><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>因此当我们设置varchar长度时，如果该字段确定不会拿来做索引，可以设置稍微长一点，比如varchar(255)，这样字段长度会更灵活一些；如果该字段有可能会被拿来做索引，那么就按需尽量设置的小一点，这样索引会有更好的性能。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 数据库 </category>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> varchar </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>关于</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[<p>大家好，我是陈泽平，欢迎来到我的个人技术博客。<br>邮箱：<a href="mailto:&#x63;&#x68;&#101;&#x6e;&#122;&#101;&#x70;&#105;&#x6e;&#x67;&#x31;&#x30;&#x31;&#x36;&#x40;&#x31;&#x32;&#54;&#x2e;&#99;&#x6f;&#x6d;">&#x63;&#x68;&#101;&#x6e;&#122;&#101;&#x70;&#105;&#x6e;&#x67;&#x31;&#x30;&#x31;&#x36;&#x40;&#x31;&#x32;&#54;&#x2e;&#99;&#x6f;&#x6d;</a><br>微信：grugczp</p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>读书</title>
      <link href="/reading/index.html"/>
      <url>/reading/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
