<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Go语言异常处理机制</title>
      <link href="/2023/10/25/golang-exception-handle/"/>
      <url>/2023/10/25/golang-exception-handle/</url>
      
        <content type="html"><![CDATA[<p>Go语言舍弃了传统的 try…catch 类似的异常处理机制，但是我们仍然可以通过Go语言提供了 panic 和 recover 函数，配合 defer 语句灵活地处理运行时的异常。  </p><h1 id="名词介绍"><a href="#名词介绍" class="headerlink" title="名词介绍"></a>名词介绍</h1><h2 id="panic"><a href="#panic" class="headerlink" title="panic"></a>panic</h2><p>Go语言的内置方法，能够改变程序的控制流。当函数调用了panic，函数会停止运行，但是defer函数仍然会运行，程序会在当前panic的goroutine全部退栈以后crash。</p><h2 id="recover"><a href="#recover" class="headerlink" title="recover"></a>recover</h2><p>Go语言的内置方法，用于恢复发生panic的goroutine的控制。如果当前goroutine将要发生panic的话，recover会捕获这个panic，并恢复正常执行。</p><h2 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h2><p>Go语言的关键字，用来延迟执行函数的，延迟的发生是在调用函数的return之后。关于defer，我在博客<a href="/2023/10/24/golang-defer">Go语言中的defer</a>中详细介绍过。而在这里为什么会提到defer呢？这是因为recover只在defer函数中生效。</p><h1 id="常见用法"><a href="#常见用法" class="headerlink" title="常见用法"></a>常见用法</h1><p>如下是一个常见的捕获异常的例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    defer func() &#123;</span><br><span class="line">        if err := recover(); err != nil &#123;</span><br><span class="line">            fmt.Println(&quot;catch panic:&quot;, err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    panic(&quot;I&#x27;m panic&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><blockquote><p>catch panic: I’m panic</p></blockquote><p>需要注意的几个点：<br>1）recover只在defer函数中生效<br>下面这几种写法，都不会捕获panic</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    if err := recover(); err != nil &#123;</span><br><span class="line">        fmt.Println(&quot;catch panic:&quot;, err)</span><br><span class="line">    &#125;</span><br><span class="line">    panic(&quot;I&#x27;m panic&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该示例输出结果：</p><blockquote><p>panic: I’m panic</p><p>goroutine 1 [running]:<br>main.main()<br>       &#x2F;Users&#x2F;chenzeping&#x2F;go&#x2F;src&#x2F;gostudy&#x2F;panic&#x2F;main.go:9 +0x3c<br>exit status 2</p></blockquote><p>上面示例中recover()在panic之前运行，此时panic还未发生，肯定不会捕获panic。<br>再看下面这个例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    panic(&quot;I&#x27;m panic&quot;)</span><br><span class="line">    if err := recover(); err != nil &#123;</span><br><span class="line">        fmt.Println(&quot;catch panic:&quot;, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该示例输出结果：</p><blockquote><p>panic: I’m panic</p><p>goroutine 1 [running]:<br>main.main()<br>       &#x2F;Users&#x2F;chenzeping&#x2F;go&#x2F;src&#x2F;gostudy&#x2F;panic&#x2F;main.go:6 +0x2c<br>exit status 2</p></blockquote><p>上面示例中recover()虽然写在了panic之后，但是由于panic后，后面的代码不会被执行，所以程序执行不到recover()，也就无法捕获panic。  </p><p>2）recover只能捕获当前goroutine的panic<br>看下面这个例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    a()</span><br><span class="line">    time.Sleep(2 * time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func a() &#123;</span><br><span class="line">    defer func() &#123;</span><br><span class="line">        fmt.Println(&quot;in defer&quot;)</span><br><span class="line">        if err := recover(); err != nil &#123;</span><br><span class="line">            fmt.Println(&quot;catch panic:&quot;, err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    go func() &#123;</span><br><span class="line">        time.Sleep(1 * time.Second)</span><br><span class="line">        panic(&quot;I&#x27;m panic&quot;)</span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><blockquote><p>in defer<br>panic: I’m panic</p><p>goroutine 18 [running]:<br>main.a.func2()<br>       &#x2F;Users&#x2F;chenzeping&#x2F;go&#x2F;src&#x2F;gostudy&#x2F;panic&#x2F;main.go:22 +0x38<br>created by main.a<br>       &#x2F;Users&#x2F;chenzeping&#x2F;go&#x2F;src&#x2F;gostudy&#x2F;panic&#x2F;main.go:20 +0x40<br>exit status 2</p></blockquote><p>从上面例子可以看出，其他goroutine中的panic并没有被recover捕获，从而最终导致程序崩溃。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 编程语言 </category>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
            <tag> defer </tag>
            
            <tag> panic </tag>
            
            <tag> recover </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言中的defer</title>
      <link href="/2023/10/24/golang-defer/"/>
      <url>/2023/10/24/golang-defer/</url>
      
        <content type="html"><![CDATA[<p>defer的功能是在作用域结束之后执行收尾的函数，defer的行为可以总结为如下四条：  </p><ol><li>defer函数的参数，是在defer函数被定义的时候就已经明确了。 </li><li>defer函数是在return执行之后运行的。</li><li>函数运行过程中出现panic，defer函数也会被执行。</li><li>defer函数的执行顺序是后进先出。</li></ol><p>下面我们通过一些例子，来详细介绍下这四条规则。<br>1）defer函数的参数，是在defer函数被定义的时候就已经明确了。   </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    a()</span><br><span class="line">&#125;</span><br><span class="line">func a() &#123;</span><br><span class="line">    i := 0</span><br><span class="line">    defer fmt.Println(i)</span><br><span class="line">    i++</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面示例输出结果：0。defer调用fmt.Println(i)时，会对函数中引用的外部参数进行拷贝，所以i++操作并没有影响到defer里的i值。<br>再看下面这个例子：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    a()</span><br><span class="line">&#125;</span><br><span class="line">func a() &#123;</span><br><span class="line">    i := 0</span><br><span class="line">    defer func() &#123;</span><br><span class="line">        fmt.Println(i)</span><br><span class="line">    &#125;()</span><br><span class="line">    i++</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个示例输出结果是：1。为什么跟上一个示例输出结果不一样呢？因为这里defer后面是一个匿名函数，而i并不是该匿名函数的外部参数，这里大家一定要注意。  </p><p>2）defer函数是在return执行之后运行的。  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    fmt.Println(&quot;main&quot;, a())</span><br><span class="line">&#125;</span><br><span class="line">func a() int &#123;</span><br><span class="line">    i := 0</span><br><span class="line">    defer func() &#123;</span><br><span class="line">        i++</span><br><span class="line">        fmt.Println(&quot;defer&quot;, i)</span><br><span class="line">    &#125;()</span><br><span class="line">    return i</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该示例运行结果是：</p><blockquote><p>defer 1<br>main 0</p></blockquote><p>虽然在defer里对i进行了操作，但是因为defer是在return执行之后运行的，所以并不会影响返回值。  </p><p>3）函数运行过程中出现panic，defer函数也会被执行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    fmt.Println(&quot;main&quot;, a())</span><br><span class="line">&#125;</span><br><span class="line">func a() int &#123;</span><br><span class="line">    i := 0</span><br><span class="line">    defer func() &#123;</span><br><span class="line">        i++</span><br><span class="line">        fmt.Println(&quot;defer1&quot;, i)</span><br><span class="line">    &#125;()</span><br><span class="line">    panic(&quot;I&#x27;m panic&quot;)</span><br><span class="line">    fmt.Println(&quot;after panic&quot;)</span><br><span class="line">    defer func() &#123;</span><br><span class="line">        i++</span><br><span class="line">        fmt.Println(&quot;defer2&quot;, i)</span><br><span class="line">    &#125;()</span><br><span class="line">    return i</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该示例运行结果是：</p><blockquote><p>defer1 1<br>panic: I’m panic</p><p>goroutine 1 [running]:<br>main.a()<br>       &#x2F;Users&#x2F;chenzeping&#x2F;go&#x2F;src&#x2F;gostudy&#x2F;defer&#x2F;main.go:14 +0x68<br>main.main()<br>       &#x2F;Users&#x2F;chenzeping&#x2F;go&#x2F;src&#x2F;gostudy&#x2F;defer&#x2F;main.go:6 +0x1c<br>exit status 2</p></blockquote><p>可以看到，在panic之前的defer被执行了，然后才是panic，panic之后的代码都没有执行。至于为什么defer会被执行，我在后面的博客<a href="/2023/10/25/golang-exception-handle">Go语言异常处理机制</a>中会详细解答。  </p><p>4）defer函数的执行顺序是后进先出。  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    a()</span><br><span class="line">&#125;</span><br><span class="line">func a() &#123;</span><br><span class="line">    defer fmt.Println(&quot;defer1&quot;)</span><br><span class="line">    defer fmt.Println(&quot;defer2&quot;)</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该示例运行结果是：</p><blockquote><p>defer2<br>defer1</p></blockquote><p>可以看到，先执行了defer2，后执行了defer1。这个也好理解，每次defer都会把一个函数压入栈中，函数返回前再把延迟的函数从栈中取出并执行，顺序是后进先出。  </p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 编程语言 </category>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
            <tag> defer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang中的单例模式</title>
      <link href="/2023/10/19/golang-single-instance/"/>
      <url>/2023/10/19/golang-single-instance/</url>
      
        <content type="html"><![CDATA[<p>Go语言中如何实现一个单例？很多Go语言学习者可能觉得这是一个很简单的问题，闭着眼都能写出来。但是其代码实现往往存在不少问题，下面先看一下一些常见的错误。</p><h1 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h1><h2 id="没考虑并发安全"><a href="#没考虑并发安全" class="headerlink" title="没考虑并发安全"></a>没考虑并发安全</h2><p>示例代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">type User struct &#123;</span><br><span class="line">    Name string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var instance *User</span><br><span class="line"></span><br><span class="line">func GetInstance() *User &#123;</span><br><span class="line">    if instance == nil &#123;</span><br><span class="line">        instance = &amp;User&#123;</span><br><span class="line">            Name: &quot;xiaoming&quot;,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return instance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面示例中，多个goroutine有可能同时执行第一个检查，然后instance就会被执行多次赋值操作，在某些instance只能被赋值一次的业务场景，该操作就可能导致与期望不一致。</p><h2 id="忽略代码非原子操作问题"><a href="#忽略代码非原子操作问题" class="headerlink" title="忽略代码非原子操作问题"></a>忽略代码非原子操作问题</h2><p>针对上面示例存在的并发问题，部分开发人员想我加个锁，问题不就解决了吗，于是将上面示例代码修改成如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">type User struct &#123;</span><br><span class="line">    Name string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var (</span><br><span class="line">    lock     sync.Mutex</span><br><span class="line">    instance *User</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func GetInstance() *User &#123;</span><br><span class="line">    if instance == nil &#123;</span><br><span class="line">        lock.Lock()</span><br><span class="line">        defer lock.Unlock()</span><br><span class="line">        if instance == nil &#123;</span><br><span class="line">            instance = &amp;User&#123;</span><br><span class="line">                Name: &quot;xiaoming&quot;,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return instance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上示例代码看似已经很完美了，但是当我们用go run -race检查时，会提示这段代码有DATA RACE的警告：</p><blockquote><p>WARNING: DATA RACE<br>Write at 0x00010507e6a0 by goroutine 6:<br> main.GetInstance()<br>     &#x2F;Users&#x2F;chenzeping&#x2F;go&#x2F;src&#x2F;gostudy&#x2F;race&#x2F;go_race_demo.go:22 +0xf4<br> main.main.func1()<br>     &#x2F;Users&#x2F;chenzeping&#x2F;go&#x2F;src&#x2F;gostudy&#x2F;race&#x2F;go_race_demo.go:32 +0x20</p><p>Previous read at 0x00010507e6a0 by goroutine 8:<br> main.GetInstance()<br>     &#x2F;Users&#x2F;chenzeping&#x2F;go&#x2F;src&#x2F;gostudy&#x2F;race&#x2F;go_race_demo.go:18 +0x30<br> main.main.func3()<br>     &#x2F;Users&#x2F;chenzeping&#x2F;go&#x2F;src&#x2F;gostudy&#x2F;race&#x2F;go_race_demo.go:38 +0x20</p><p>Goroutine 6 (running) created at:<br> main.main()<br>     &#x2F;Users&#x2F;chenzeping&#x2F;go&#x2F;src&#x2F;gostudy&#x2F;race&#x2F;go_race_demo.go:31 +0x28</p><p>Goroutine 8 (running) created at:<br> main.main()<br>     &#x2F;Users&#x2F;chenzeping&#x2F;go&#x2F;src&#x2F;gostudy&#x2F;race&#x2F;go_race_demo.go:37 +0x40</p></blockquote><p>大家可以亲自试一下，go_race_demo.go完整代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;sync&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type User struct &#123;</span><br><span class="line">    Name string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var (</span><br><span class="line">    lock     sync.Mutex</span><br><span class="line">    instance *User</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func GetInstance() *User &#123;</span><br><span class="line">    if instance == nil &#123;</span><br><span class="line">        lock.Lock()</span><br><span class="line">        defer lock.Unlock()</span><br><span class="line">        if instance == nil &#123;</span><br><span class="line">            instance = &amp;User&#123;</span><br><span class="line">                Name: &quot;xiaoming&quot;,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return instance</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    go func() &#123;</span><br><span class="line">        fmt.Println(&quot;goroutine A&quot;, GetInstance())</span><br><span class="line">    &#125;()</span><br><span class="line">    go func() &#123;</span><br><span class="line">        fmt.Println(&quot;goroutine B&quot;, GetInstance())</span><br><span class="line">    &#125;()</span><br><span class="line">    go func() &#123;</span><br><span class="line">        fmt.Println(&quot;goroutine C&quot;, GetInstance())</span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之所以会出现DATA RACE警告，是因为CPU在执行instance&#x3D;&amp;User{Name:”xiaoming”}这行代码时，并不是原子操作，这个赋值可能是会有几步指令，比如</p><ol><li>先new一个User</li><li>然后设置Name&#x3D;xiaoming</li><li>最后把了new的对象赋值给instance</li></ol><p>而且多个指令执行时，有可能会是乱序的，如果发生了乱序，可能会变成</p><ol><li>先了new一个User</li><li>然后再赋值给instance</li><li>最后再设置Name&#x3D;xiaoming</li></ol><p>goroutine A进来时拿到锁，然后执行instance&#x3D;&amp;User{Name:”xiaoming”}这句代码，这个时候有可能刚执行完指令2，还未执行指令3时，goroutine B对instance是否为nil进行了判断，发现非nil，就直接将instance的数据返回了，而此时的instance是个半初始化状态，这时就会有问题。</p><h1 id="正确姿势"><a href="#正确姿势" class="headerlink" title="正确姿势"></a>正确姿势</h1><p>解决上面的问题，我们可以通过原子化加载并设置一个标志flag，该标志表明我们是否已初始化instance，改造后代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">type User struct &#123;</span><br><span class="line">    Name string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var (</span><br><span class="line">    lock     sync.Mutex</span><br><span class="line">    instance *User</span><br><span class="line">    flag     uint32</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func GetInstance() *User &#123;</span><br><span class="line">    if atomic.LoadUint32(&amp;flag) != 1 &#123;</span><br><span class="line">        lock.Lock()</span><br><span class="line">        defer lock.Unlock()</span><br><span class="line">        if instance == nil &#123;</span><br><span class="line">            instance = &amp;User&#123;</span><br><span class="line">                Name: &quot;xiaoming&quot;,</span><br><span class="line">            &#125;</span><br><span class="line">            atomic.StoreUint32(&amp;flag, 1)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return instance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，我们主要是通过atomic.store和lock来保证flag和instance的修改对其他的goroutine可见，通过atomic.LoadUint32(&amp;flag)和double check来保证instance只会被初始化一次。<br>但是，这看起来有点繁琐，其实Go语言标准库sync已经为我们提供了实现goroutine同步比较好的方式，通过<code>sync.Once</code>来实现，示例代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">type User struct &#123;</span><br><span class="line">    Name string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var (</span><br><span class="line">    once sync.Once</span><br><span class="line">    instance *User</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func GetInstance() *User &#123;</span><br><span class="line">    once.Do(func() &#123;</span><br><span class="line">        instance = &amp;User&#123;</span><br><span class="line">            Name: &quot;xiaoming&quot;,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    return instance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，我们可以首选<code>sync.Once</code>来实现单例模式。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 编程语言 </category>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
            <tag> 单例 </tag>
            
            <tag> 并发 </tag>
            
            <tag> Go内存模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Apple arm架构下gomonkey报错问题解决</title>
      <link href="/2023/10/11/apple-arm-gomonkey-error/"/>
      <url>/2023/10/11/apple-arm-gomonkey-error/</url>
      
        <content type="html"><![CDATA[<h1 id="问题一：-undefined-buildJmpDirective"><a href="#问题一：-undefined-buildJmpDirective" class="headerlink" title="问题一： undefined: buildJmpDirective"></a>问题一： undefined: buildJmpDirective</h1><p>需要将gomonkey升级到github.com&#x2F;agiledragon&#x2F;gomonkey&#x2F;v2</p><h1 id="问题二：permission-denied"><a href="#问题二：permission-denied" class="headerlink" title="问题二：permission denied"></a>问题二：permission denied</h1><p>修改modify_binary_darwin.go文件，去掉syscall.PROT_EXEC<br><img src="/2023/10/11/apple-arm-gomonkey-error/1280X1280.png"></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 编程语言 </category>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> arm </tag>
            
            <tag> gomonkey </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL中varchar类型长度设置为多少合适</title>
      <link href="/2023/10/11/mysql-varchar-length/"/>
      <url>/2023/10/11/mysql-varchar-length/</url>
      
        <content type="html"><![CDATA[<h1 id="varchar类型长度常见设置"><a href="#varchar类型长度常见设置" class="headerlink" title="varchar类型长度常见设置"></a>varchar类型长度常见设置</h1><p>经常会看到大家设置varchar类型长度，一般都设置为255，那为什么不是其他数字呢？<br><br>以下针对我们常用的<em>innodb</em>存储引擎。</p><h1 id="varchar-255-和varchar-256-区别"><a href="#varchar-255-和varchar-256-区别" class="headerlink" title="varchar(255)和varchar(256)区别"></a>varchar(255)和varchar(256)区别</h1><p>varchar(255)需要1个字节记录字符串长度，而varchar(256)则需要2个字节记录字符串长度。<br>因此varchar(255)和varchar(256)，优先选择varchar(255)。</p><h1 id="varchar-64-和varchar-255-区别"><a href="#varchar-64-和varchar-255-区别" class="headerlink" title="varchar(64)和varchar(255)区别"></a>varchar(64)和varchar(255)区别</h1><ol><li>对于字符串长度超过64的，varchar(64)的sql会报错  </li><li>对于字符串长度不超过64的，两者在磁盘存储上没有区别<ol><li>都是1个字节记录字符串长度</li><li>由于innodb将varchar类型数据独立于聚簇索引单独存储，占用空间取决于实际字符串长度</li></ol></li></ol><p>所以如果字段长度不超过64，那么使用varchar(255)也没问题，但是如果该字段建<strong>索引</strong>了，那就不一样了：<br>建立索引时如果没有限制索引的大小，索引长度会默认采用的该字段类型的长度，因此用varchar(255)类型会占用更多的空间，加载索引信息时也会占用更多的内存，索引性能相对来说会较差。</p><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>因此当我们设置varchar长度时，如果该字段确定不会拿来做索引，可以设置稍微长一点，比如varchar(255)，这样字段长度会更灵活一些；如果该字段有可能会被拿来做索引，那么就按需尽量设置的小一点，这样索引会有更好的性能。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 数据库 </category>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> varchar </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>关于</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[<p>大家好，我是陈泽平，欢迎来到我的个人技术博客。<br>邮箱：<a href="mailto:&#x63;&#x68;&#101;&#x6e;&#122;&#101;&#x70;&#105;&#x6e;&#x67;&#x31;&#x30;&#x31;&#x36;&#x40;&#x31;&#x32;&#54;&#x2e;&#99;&#x6f;&#x6d;">&#x63;&#x68;&#101;&#x6e;&#122;&#101;&#x70;&#105;&#x6e;&#x67;&#x31;&#x30;&#x31;&#x36;&#x40;&#x31;&#x32;&#54;&#x2e;&#99;&#x6f;&#x6d;</a><br>微信：grugczp</p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>读书</title>
      <link href="/reading/index.html"/>
      <url>/reading/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
