<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Go语言中的sync.Cond</title>
      <link href="/article/golang-sync-cond/"/>
      <url>/article/golang-sync-cond/</url>
      
        <content type="html"><![CDATA[<p>Go语言并发编程中，经常会用到 sync 包。sync包提供了Once、Mutex、Rwmutex、Cond、Map、Pool、Waitgroup等模块，其中 Cond 模块最不常用，很少见在实际业务中有应用到的。那么今天我们就来介绍一下 Cond 模块以及其应用场景，以帮助大家在处理并发编程相关问题时，能够多一个选择。</p><h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p>sync.Cond 经常用在多个协程等待事件发生，一个协程通知事件发生的场景。举个例子：<br>有一个协程在异步地接收数据，剩下的多个协程必须等待这个协程接收完数据，才能读取到正确的数据。在这种情况下，如果单纯使用通道或互斥锁，那么只能有一个协程可以等待，并读取到数据，没办法通知其他的协程也读取数据。<br>sync.Cond 就是用来解决如上这类问题的。</p><h1 id="sync-Cond源码分析"><a href="#sync-Cond源码分析" class="headerlink" title="sync.Cond源码分析"></a>sync.Cond源码分析</h1><h2 id="sync-Cond-定义"><a href="#sync-Cond-定义" class="headerlink" title="sync.Cond 定义"></a>sync.Cond 定义</h2><p>sync.Cond 定义如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">type Cond struct &#123;</span><br><span class="line">    noCopy noCopy</span><br><span class="line"></span><br><span class="line">    // L is held while observing or changing the condition</span><br><span class="line">    L Locker</span><br><span class="line"></span><br><span class="line">    notify  notifyList</span><br><span class="line">    checker copyChecker</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个 Cond 实例都会关联一个锁 L（互斥锁 *Mutex，或读写锁 *RWMutex），当修改条件或者调用 Wait 方法时，需要进行加锁。</p><h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><h3 id="NewCond-创建实例"><a href="#NewCond-创建实例" class="headerlink" title="NewCond 创建实例"></a>NewCond 创建实例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// NewCond returns a new Cond with Locker l.</span><br><span class="line">func NewCond(l Locker) *Cond &#123;</span><br><span class="line">    return &amp;Cond&#123;L: l&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过调用 NewCond创建一个 Cond 实例，注意，创建 Cond 实例时需要关联一个锁。</p><h3 id="Wait-等待"><a href="#Wait-等待" class="headerlink" title="Wait 等待"></a>Wait 等待</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// Wait atomically unlocks c.L and suspends execution</span><br><span class="line">// of the calling goroutine. After later resuming execution,</span><br><span class="line">// Wait locks c.L before returning. Unlike in other systems,</span><br><span class="line">// Wait cannot return unless awoken by Broadcast or Signal.</span><br><span class="line">//</span><br><span class="line">// Because c.L is not locked while Wait is waiting, the caller</span><br><span class="line">// typically cannot assume that the condition is true when</span><br><span class="line">// Wait returns. Instead, the caller should Wait in a loop:</span><br><span class="line">//</span><br><span class="line">//    c.L.Lock()</span><br><span class="line">//    for !condition() &#123;</span><br><span class="line">//        c.Wait()</span><br><span class="line">//    &#125;</span><br><span class="line">//    ... make use of condition ...</span><br><span class="line">//    c.L.Unlock()</span><br><span class="line">func (c *Cond) Wait() &#123;</span><br><span class="line">    c.checker.check()</span><br><span class="line">    t := runtime_notifyListAdd(&amp;c.notify)</span><br><span class="line">    c.L.Unlock()</span><br><span class="line">    runtime_notifyListWait(&amp;c.notify, t)</span><br><span class="line">    c.L.Lock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们翻译一下 Wait 方法的注释：<br>Wait 会原子性地释放锁 c.L，并将当前协程挂起，也就是当前协程会阻塞在 Wait 方法里。当其他协程调用了 Broadcast 或 Signal 时，当前协程被唤醒，然后 Wait 方法会重新给 c.L 加锁，并且继续执行 Wait 后面的代码。<br>由于当前协程被唤醒时，condition 并不一定符合要求，因此需要再次判断一下condition，所以推荐使用 <code>for !condition()</code> 而非 <code>if</code>。</p><h3 id="Signal-唤醒单个协程"><a href="#Signal-唤醒单个协程" class="headerlink" title="Signal 唤醒单个协程"></a>Signal 唤醒单个协程</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// Signal wakes one goroutine waiting on c, if there is any.</span><br><span class="line">//</span><br><span class="line">// It is allowed but not required for the caller to hold c.L</span><br><span class="line">// during the call.</span><br><span class="line">//</span><br><span class="line">// Signal() does not affect goroutine scheduling priority; if other goroutines</span><br><span class="line">// are attempting to lock c.L, they may be awoken before a &quot;waiting&quot; goroutine.</span><br><span class="line">func (c *Cond) Signal() &#123;</span><br><span class="line">    c.checker.check()</span><br><span class="line">    runtime_notifyListNotifyOne(&amp;c.notify)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Signal() 会唤醒一个正在等待的协程（如果有的话），调用者在调用期间可以持有 c.L，但这不是必需的。</p><h3 id="Broadcast-广播唤醒所有协程"><a href="#Broadcast-广播唤醒所有协程" class="headerlink" title="Broadcast 广播唤醒所有协程"></a>Broadcast 广播唤醒所有协程</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// Broadcast wakes all goroutines waiting on c.</span><br><span class="line">//</span><br><span class="line">// It is allowed but not required for the caller to hold c.L</span><br><span class="line">// during the call.</span><br><span class="line">func (c *Cond) Broadcast() &#123;</span><br><span class="line">    c.checker.check()</span><br><span class="line">    runtime_notifyListNotifyAll(&amp;c.notify)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Broadcast() 会唤醒所有正在等待的协程，同样调用者在调用期间可以持有 c.L，但这不是必需的。</p><h1 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h1><p>下面是一个简单的使用 sync.Cond 的示例：一个协程写入数据，另外几个协程等待并读取数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;log&quot;</span><br><span class="line">    &quot;sync&quot;</span><br><span class="line">    &quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var done = false</span><br><span class="line"></span><br><span class="line">func read(name string, c *sync.Cond) &#123;</span><br><span class="line">    c.L.Lock()</span><br><span class="line">    for !done &#123;</span><br><span class="line">        log.Println(name, &quot;waiting&quot;)</span><br><span class="line">        c.Wait()</span><br><span class="line">    &#125;</span><br><span class="line">    log.Println(name, &quot;start reading&quot;)</span><br><span class="line">    c.L.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    c := sync.NewCond(&amp;sync.Mutex&#123;&#125;)</span><br><span class="line">    // 启动3个reader</span><br><span class="line">    go read(&quot;reader1&quot;, c)</span><br><span class="line">    go read(&quot;reader2&quot;, c)</span><br><span class="line">    go read(&quot;reader3&quot;, c)</span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">    // 开始写数据</span><br><span class="line">    log.Println(&quot;start writing&quot;)</span><br><span class="line">    done = true</span><br><span class="line">    log.Println(&quot;write done&quot;)</span><br><span class="line">    // 唤醒一个协程</span><br><span class="line">    log.Println(&quot;wake one&quot;)</span><br><span class="line">    c.Signal()</span><br><span class="line">    // 由于已经done，所以reader4并不会进入wait</span><br><span class="line">    go read(&quot;reader4&quot;, c)</span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">    // 唤醒其他所有协程</span><br><span class="line">    log.Println(&quot;wake all&quot;)</span><br><span class="line">    c.Broadcast()</span><br><span class="line">    time.Sleep(time.Second * 3)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><blockquote><p>2023&#x2F;10&#x2F;31 17:11:16 reader1 waiting<br>2023&#x2F;10&#x2F;31 17:11:16 reader2 waiting<br>2023&#x2F;10&#x2F;31 17:11:16 reader3 waiting<br>2023&#x2F;10&#x2F;31 17:11:17 start writing<br>2023&#x2F;10&#x2F;31 17:11:17 write done<br>2023&#x2F;10&#x2F;31 17:11:17 wake one<br>2023&#x2F;10&#x2F;31 17:11:17 reader1 start reading<br>2023&#x2F;10&#x2F;31 17:11:17 reader4 start reading<br>2023&#x2F;10&#x2F;31 17:11:18 wake all<br>2023&#x2F;10&#x2F;31 17:11:18 reader3 start reading<br>2023&#x2F;10&#x2F;31 17:11:18 reader2 start reading</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 编程语言 </category>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
            <tag> sync </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言异常处理机制</title>
      <link href="/article/golang-exception-handle/"/>
      <url>/article/golang-exception-handle/</url>
      
        <content type="html"><![CDATA[<p>Go语言舍弃了传统的 try…catch 类似的异常处理机制，但是我们仍然可以通过Go语言提供了 panic 和 recover 函数，配合 defer 语句灵活地处理运行时的异常。  </p><h1 id="名词介绍"><a href="#名词介绍" class="headerlink" title="名词介绍"></a>名词介绍</h1><h2 id="panic"><a href="#panic" class="headerlink" title="panic"></a>panic</h2><p>Go语言的内置方法，能够改变程序的控制流。当函数调用了panic，函数会停止运行，但是defer函数仍然会运行，程序会在当前panic的goroutine全部退栈以后crash。</p><h2 id="recover"><a href="#recover" class="headerlink" title="recover"></a>recover</h2><p>Go语言的内置方法，用于恢复发生panic的goroutine的控制。如果当前goroutine将要发生panic的话，recover会捕获这个panic，并恢复正常执行。</p><h2 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h2><p>Go语言的关键字，用来延迟执行函数的，延迟的发生是在调用函数的return之后。关于defer，我在博客<a href="/article/golang-defer">Go语言中的defer</a>中详细介绍过。而在这里为什么会提到defer呢？这是因为recover只在defer函数中生效。</p><h1 id="常见用法"><a href="#常见用法" class="headerlink" title="常见用法"></a>常见用法</h1><p>如下是一个常见的捕获异常的例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    defer func() &#123;</span><br><span class="line">        if err := recover(); err != nil &#123;</span><br><span class="line">            fmt.Println(&quot;catch panic:&quot;, err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    panic(&quot;I&#x27;m panic&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><blockquote><p>catch panic: I’m panic</p></blockquote><p>需要注意的几个点：<br>1）recover只在defer函数中生效<br>下面这几种写法，都不会捕获panic</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    if err := recover(); err != nil &#123;</span><br><span class="line">        fmt.Println(&quot;catch panic:&quot;, err)</span><br><span class="line">    &#125;</span><br><span class="line">    panic(&quot;I&#x27;m panic&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该示例输出结果：</p><blockquote><p>panic: I’m panic</p><p>goroutine 1 [running]:<br>main.main()<br>       &#x2F;Users&#x2F;chenzeping&#x2F;go&#x2F;src&#x2F;gostudy&#x2F;panic&#x2F;main.go:9 +0x3c<br>exit status 2</p></blockquote><p>上面示例中recover()在panic之前运行，此时panic还未发生，肯定不会捕获panic。<br>再看下面这个例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    panic(&quot;I&#x27;m panic&quot;)</span><br><span class="line">    if err := recover(); err != nil &#123;</span><br><span class="line">        fmt.Println(&quot;catch panic:&quot;, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该示例输出结果：</p><blockquote><p>panic: I’m panic</p><p>goroutine 1 [running]:<br>main.main()<br>       &#x2F;Users&#x2F;chenzeping&#x2F;go&#x2F;src&#x2F;gostudy&#x2F;panic&#x2F;main.go:6 +0x2c<br>exit status 2</p></blockquote><p>上面示例中recover()虽然写在了panic之后，但是由于panic后，后面的代码不会被执行，所以程序执行不到recover()，也就无法捕获panic。  </p><p>2）recover只能捕获当前goroutine的panic<br>看下面这个例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    a()</span><br><span class="line">    time.Sleep(2 * time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func a() &#123;</span><br><span class="line">    defer func() &#123;</span><br><span class="line">        fmt.Println(&quot;in defer&quot;)</span><br><span class="line">        if err := recover(); err != nil &#123;</span><br><span class="line">            fmt.Println(&quot;catch panic:&quot;, err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    go func() &#123;</span><br><span class="line">        time.Sleep(1 * time.Second)</span><br><span class="line">        panic(&quot;I&#x27;m panic&quot;)</span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><blockquote><p>in defer<br>panic: I’m panic</p><p>goroutine 18 [running]:<br>main.a.func2()<br>       &#x2F;Users&#x2F;chenzeping&#x2F;go&#x2F;src&#x2F;gostudy&#x2F;panic&#x2F;main.go:22 +0x38<br>created by main.a<br>       &#x2F;Users&#x2F;chenzeping&#x2F;go&#x2F;src&#x2F;gostudy&#x2F;panic&#x2F;main.go:20 +0x40<br>exit status 2</p></blockquote><p>从上面例子可以看出，其他goroutine中的panic并没有被recover捕获，从而最终导致程序崩溃。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 编程语言 </category>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
            <tag> defer </tag>
            
            <tag> panic </tag>
            
            <tag> recover </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言中的defer</title>
      <link href="/article/golang-defer/"/>
      <url>/article/golang-defer/</url>
      
        <content type="html"><![CDATA[<p>defer的功能是在作用域结束之后执行收尾的函数，defer的行为可以总结为如下四条：  </p><ol><li>defer函数的参数，是在defer函数被定义的时候就已经明确了。 </li><li>defer函数是在return执行之后运行的。</li><li>函数运行过程中出现panic，defer函数也会被执行。</li><li>defer函数的执行顺序是后进先出。</li></ol><p>下面我们通过一些例子，来详细介绍下这四条规则。<br>1）defer函数的参数，是在defer函数被定义的时候就已经明确了。   </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    a()</span><br><span class="line">&#125;</span><br><span class="line">func a() &#123;</span><br><span class="line">    i := 0</span><br><span class="line">    defer fmt.Println(i)</span><br><span class="line">    i++</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面示例输出结果：0。defer调用fmt.Println(i)时，会对函数中引用的外部参数进行拷贝，所以i++操作并没有影响到defer里的i值。<br>再看下面这个例子：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    a()</span><br><span class="line">&#125;</span><br><span class="line">func a() &#123;</span><br><span class="line">    i := 0</span><br><span class="line">    defer func() &#123;</span><br><span class="line">        fmt.Println(i)</span><br><span class="line">    &#125;()</span><br><span class="line">    i++</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个示例输出结果是：1。为什么跟上一个示例输出结果不一样呢？因为这里defer后面是一个匿名函数，而i并不是该匿名函数的外部参数，这里大家一定要注意。  </p><p>2）defer函数是在return执行之后运行的。  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    fmt.Println(&quot;main&quot;, a())</span><br><span class="line">&#125;</span><br><span class="line">func a() int &#123;</span><br><span class="line">    i := 0</span><br><span class="line">    defer func() &#123;</span><br><span class="line">        i++</span><br><span class="line">        fmt.Println(&quot;defer&quot;, i)</span><br><span class="line">    &#125;()</span><br><span class="line">    return i</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该示例运行结果是：</p><blockquote><p>defer 1<br>main 0</p></blockquote><p>虽然在defer里对i进行了操作，但是因为defer是在return执行之后运行的，所以并不会影响返回值。  </p><p>3）函数运行过程中出现panic，defer函数也会被执行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    fmt.Println(&quot;main&quot;, a())</span><br><span class="line">&#125;</span><br><span class="line">func a() int &#123;</span><br><span class="line">    i := 0</span><br><span class="line">    defer func() &#123;</span><br><span class="line">        i++</span><br><span class="line">        fmt.Println(&quot;defer1&quot;, i)</span><br><span class="line">    &#125;()</span><br><span class="line">    panic(&quot;I&#x27;m panic&quot;)</span><br><span class="line">    fmt.Println(&quot;after panic&quot;)</span><br><span class="line">    defer func() &#123;</span><br><span class="line">        i++</span><br><span class="line">        fmt.Println(&quot;defer2&quot;, i)</span><br><span class="line">    &#125;()</span><br><span class="line">    return i</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该示例运行结果是：</p><blockquote><p>defer1 1<br>panic: I’m panic</p><p>goroutine 1 [running]:<br>main.a()<br>       &#x2F;Users&#x2F;chenzeping&#x2F;go&#x2F;src&#x2F;gostudy&#x2F;defer&#x2F;main.go:14 +0x68<br>main.main()<br>       &#x2F;Users&#x2F;chenzeping&#x2F;go&#x2F;src&#x2F;gostudy&#x2F;defer&#x2F;main.go:6 +0x1c<br>exit status 2</p></blockquote><p>可以看到，在panic之前的defer被执行了，然后才是panic，panic之后的代码都没有执行。关于defer在处理panic中的作用，我在后面的博客<a href="/article/golang-exception-handle">Go语言异常处理机制</a>中会详细解答。  </p><p>4）defer函数的执行顺序是后进先出。  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    a()</span><br><span class="line">&#125;</span><br><span class="line">func a() &#123;</span><br><span class="line">    defer fmt.Println(&quot;defer1&quot;)</span><br><span class="line">    defer fmt.Println(&quot;defer2&quot;)</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该示例运行结果是：</p><blockquote><p>defer2<br>defer1</p></blockquote><p>可以看到，先执行了defer2，后执行了defer1。这个也好理解，每次defer都会把一个函数压入栈中，函数返回前再把延迟的函数从栈中取出并执行，顺序是后进先出。  </p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 编程语言 </category>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
            <tag> defer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang中的单例模式</title>
      <link href="/article/golang-single-instance/"/>
      <url>/article/golang-single-instance/</url>
      
        <content type="html"><![CDATA[<p>Go语言中如何实现一个单例？很多Go语言学习者可能觉得这是一个很简单的问题，闭着眼都能写出来。但是其代码实现往往存在不少问题，下面先看一下一些常见的错误。</p><h1 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h1><h2 id="没考虑并发安全"><a href="#没考虑并发安全" class="headerlink" title="没考虑并发安全"></a>没考虑并发安全</h2><p>示例代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">type User struct &#123;</span><br><span class="line">    Name string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var instance *User</span><br><span class="line"></span><br><span class="line">func GetInstance() *User &#123;</span><br><span class="line">    if instance == nil &#123;</span><br><span class="line">        instance = &amp;User&#123;</span><br><span class="line">            Name: &quot;xiaoming&quot;,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return instance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面示例中，多个goroutine有可能同时执行第一个检查，然后instance就会被执行多次赋值操作，在某些instance只能被赋值一次的业务场景，该操作就可能导致与期望不一致。</p><h2 id="忽略代码非原子操作问题"><a href="#忽略代码非原子操作问题" class="headerlink" title="忽略代码非原子操作问题"></a>忽略代码非原子操作问题</h2><p>针对上面示例存在的并发问题，部分开发人员想我加个锁，问题不就解决了吗，于是将上面示例代码修改成如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">type User struct &#123;</span><br><span class="line">    Name string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var (</span><br><span class="line">    lock     sync.Mutex</span><br><span class="line">    instance *User</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func GetInstance() *User &#123;</span><br><span class="line">    if instance == nil &#123;</span><br><span class="line">        lock.Lock()</span><br><span class="line">        defer lock.Unlock()</span><br><span class="line">        if instance == nil &#123;</span><br><span class="line">            instance = &amp;User&#123;</span><br><span class="line">                Name: &quot;xiaoming&quot;,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return instance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上示例代码看似已经很完美了，但是当我们用go run -race检查时，会提示这段代码有DATA RACE的警告：</p><blockquote><p>WARNING: DATA RACE<br>Write at 0x00010507e6a0 by goroutine 6:<br> main.GetInstance()<br>     &#x2F;Users&#x2F;chenzeping&#x2F;go&#x2F;src&#x2F;gostudy&#x2F;race&#x2F;go_race_demo.go:22 +0xf4<br> main.main.func1()<br>     &#x2F;Users&#x2F;chenzeping&#x2F;go&#x2F;src&#x2F;gostudy&#x2F;race&#x2F;go_race_demo.go:32 +0x20</p><p>Previous read at 0x00010507e6a0 by goroutine 8:<br> main.GetInstance()<br>     &#x2F;Users&#x2F;chenzeping&#x2F;go&#x2F;src&#x2F;gostudy&#x2F;race&#x2F;go_race_demo.go:18 +0x30<br> main.main.func3()<br>     &#x2F;Users&#x2F;chenzeping&#x2F;go&#x2F;src&#x2F;gostudy&#x2F;race&#x2F;go_race_demo.go:38 +0x20</p><p>Goroutine 6 (running) created at:<br> main.main()<br>     &#x2F;Users&#x2F;chenzeping&#x2F;go&#x2F;src&#x2F;gostudy&#x2F;race&#x2F;go_race_demo.go:31 +0x28</p><p>Goroutine 8 (running) created at:<br> main.main()<br>     &#x2F;Users&#x2F;chenzeping&#x2F;go&#x2F;src&#x2F;gostudy&#x2F;race&#x2F;go_race_demo.go:37 +0x40</p></blockquote><p>大家可以亲自试一下，go_race_demo.go完整代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;sync&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type User struct &#123;</span><br><span class="line">    Name string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var (</span><br><span class="line">    lock     sync.Mutex</span><br><span class="line">    instance *User</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func GetInstance() *User &#123;</span><br><span class="line">    if instance == nil &#123;</span><br><span class="line">        lock.Lock()</span><br><span class="line">        defer lock.Unlock()</span><br><span class="line">        if instance == nil &#123;</span><br><span class="line">            instance = &amp;User&#123;</span><br><span class="line">                Name: &quot;xiaoming&quot;,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return instance</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    go func() &#123;</span><br><span class="line">        fmt.Println(&quot;goroutine A&quot;, GetInstance())</span><br><span class="line">    &#125;()</span><br><span class="line">    go func() &#123;</span><br><span class="line">        fmt.Println(&quot;goroutine B&quot;, GetInstance())</span><br><span class="line">    &#125;()</span><br><span class="line">    go func() &#123;</span><br><span class="line">        fmt.Println(&quot;goroutine C&quot;, GetInstance())</span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之所以会出现DATA RACE警告，是因为CPU在执行instance&#x3D;&amp;User{Name:”xiaoming”}这行代码时，并不是原子操作，这个赋值可能是会有几步指令，比如</p><ol><li>先new一个User</li><li>然后设置Name&#x3D;xiaoming</li><li>最后把了new的对象赋值给instance</li></ol><p>而且多个指令执行时，有可能会是乱序的，如果发生了乱序，可能会变成</p><ol><li>先了new一个User</li><li>然后再赋值给instance</li><li>最后再设置Name&#x3D;xiaoming</li></ol><p>goroutine A进来时拿到锁，然后执行instance&#x3D;&amp;User{Name:”xiaoming”}这句代码，这个时候有可能刚执行完指令2，还未执行指令3时，goroutine B对instance是否为nil进行了判断，发现非nil，就直接将instance的数据返回了，而此时的instance是个半初始化状态，这时就会有问题。</p><h1 id="正确姿势"><a href="#正确姿势" class="headerlink" title="正确姿势"></a>正确姿势</h1><p>解决上面的问题，我们可以通过原子化加载并设置一个标志flag，该标志表明我们是否已初始化instance，改造后代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">type User struct &#123;</span><br><span class="line">    Name string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var (</span><br><span class="line">    lock     sync.Mutex</span><br><span class="line">    instance *User</span><br><span class="line">    flag     uint32</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func GetInstance() *User &#123;</span><br><span class="line">    if atomic.LoadUint32(&amp;flag) != 1 &#123;</span><br><span class="line">        lock.Lock()</span><br><span class="line">        defer lock.Unlock()</span><br><span class="line">        if instance == nil &#123;</span><br><span class="line">            instance = &amp;User&#123;</span><br><span class="line">                Name: &quot;xiaoming&quot;,</span><br><span class="line">            &#125;</span><br><span class="line">            atomic.StoreUint32(&amp;flag, 1)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return instance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，我们主要是通过atomic.store和lock来保证flag和instance的修改对其他的goroutine可见，通过atomic.LoadUint32(&amp;flag)和double check来保证instance只会被初始化一次。<br>但是，这看起来有点繁琐，其实Go语言标准库sync已经为我们提供了实现goroutine同步比较好的方式，通过<code>sync.Once</code>来实现，示例代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">type User struct &#123;</span><br><span class="line">    Name string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var (</span><br><span class="line">    once sync.Once</span><br><span class="line">    instance *User</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func GetInstance() *User &#123;</span><br><span class="line">    once.Do(func() &#123;</span><br><span class="line">        instance = &amp;User&#123;</span><br><span class="line">            Name: &quot;xiaoming&quot;,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    return instance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，我们可以首选<code>sync.Once</code>来实现单例模式。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 编程语言 </category>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
            <tag> 单例 </tag>
            
            <tag> 并发 </tag>
            
            <tag> Go内存模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Apple arm架构下gomonkey报错问题解决</title>
      <link href="/article/apple-arm-gomonkey-error/"/>
      <url>/article/apple-arm-gomonkey-error/</url>
      
        <content type="html"><![CDATA[<h1 id="问题一：-undefined-buildJmpDirective"><a href="#问题一：-undefined-buildJmpDirective" class="headerlink" title="问题一： undefined: buildJmpDirective"></a>问题一： undefined: buildJmpDirective</h1><p>需要将gomonkey升级到github.com&#x2F;agiledragon&#x2F;gomonkey&#x2F;<a href="mailto:&#x76;&#x32;&#x40;&#118;&#50;&#x2e;&#49;&#48;&#x2e;&#x31;">&#x76;&#x32;&#x40;&#118;&#50;&#x2e;&#49;&#48;&#x2e;&#x31;</a></p><h1 id="问题二：permission-denied"><a href="#问题二：permission-denied" class="headerlink" title="问题二：permission denied"></a>问题二：permission denied</h1><p>修改modify_binary_darwin.go文件，去掉syscall.PROT_EXEC<br><img src="/article/apple-arm-gomonkey-error/1280X1280.png"></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 编程语言 </category>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> arm </tag>
            
            <tag> gomonkey </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL中varchar类型长度设置为多少合适</title>
      <link href="/article/mysql-varchar-length/"/>
      <url>/article/mysql-varchar-length/</url>
      
        <content type="html"><![CDATA[<h1 id="varchar类型长度常见设置"><a href="#varchar类型长度常见设置" class="headerlink" title="varchar类型长度常见设置"></a>varchar类型长度常见设置</h1><p>经常会看到大家设置varchar类型长度，一般都设置为255，那为什么不是其他数字呢？<br><br>以下针对我们常用的<em>innodb</em>存储引擎。</p><h1 id="varchar-255-和varchar-256-区别"><a href="#varchar-255-和varchar-256-区别" class="headerlink" title="varchar(255)和varchar(256)区别"></a>varchar(255)和varchar(256)区别</h1><p>varchar(255)需要1个字节记录字符串长度，而varchar(256)则需要2个字节记录字符串长度。<br>因此varchar(255)和varchar(256)，优先选择varchar(255)。</p><h1 id="varchar-64-和varchar-255-区别"><a href="#varchar-64-和varchar-255-区别" class="headerlink" title="varchar(64)和varchar(255)区别"></a>varchar(64)和varchar(255)区别</h1><ol><li>对于字符串长度超过64的，varchar(64)的sql会报错  </li><li>对于字符串长度不超过64的，两者在磁盘存储上没有区别<ol><li>都是1个字节记录字符串长度</li><li>由于innodb将varchar类型数据独立于聚簇索引单独存储，占用空间取决于实际字符串长度</li></ol></li></ol><p>所以如果字段长度不超过64，那么使用varchar(255)也没问题，但是如果该字段建<strong>索引</strong>了，那就不一样了：<br>建立索引时如果没有限制索引的大小，索引长度会默认采用的该字段类型的长度，因此用varchar(255)类型会占用更多的空间，加载索引信息时也会占用更多的内存，索引性能相对来说会较差。</p><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>因此当我们设置varchar长度时，如果该字段确定不会拿来做索引，可以设置稍微长一点，比如varchar(255)，这样字段长度会更灵活一些；如果该字段有可能会被拿来做索引，那么就按需尽量设置的小一点，这样索引会有更好的性能。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 数据库 </category>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> varchar </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>关于</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[<p>大家好，我是陈泽平，欢迎来到我的个人技术博客。<br>邮箱：<a href="mailto:&#x63;&#x68;&#101;&#x6e;&#122;&#101;&#x70;&#105;&#x6e;&#x67;&#x31;&#x30;&#x31;&#x36;&#x40;&#x31;&#x32;&#54;&#x2e;&#99;&#x6f;&#x6d;">&#x63;&#x68;&#101;&#x6e;&#122;&#101;&#x70;&#105;&#x6e;&#x67;&#x31;&#x30;&#x31;&#x36;&#x40;&#x31;&#x32;&#54;&#x2e;&#99;&#x6f;&#x6d;</a><br>微信：grugczp</p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>读书</title>
      <link href="/reading/index.html"/>
      <url>/reading/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
